<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Modelo/HighscoreManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Modelo/HighscoreManager.java" />
              <option name="originalContent" value="package Modelo;&#10;&#10;import Vista.InterfazConsola;&#10;&#10;import java.io.*;&#10;import java.nio.charset.StandardCharsets;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;/**&#10; * Gestor simple de highscores para modo SOLO.&#10; * &lt;p&gt;&#10; * Mantiene las top 5 entradas en un archivo JSON simple.&#10; * Implementa un fallback sencillo sin depender de librerías externas.&#10; * &lt;/p&gt;&#10; */&#10;public class HighscoreManager {&#10;    private static final String DEFAULT_FILE = &quot;highscores_solo.json&quot;;&#10;    private static final int MAX_ENTRIES = 5;&#10;&#10;    private final InterfazConsola consola = InterfazConsola.obtenerInstancia();&#10;&#10;    /**&#10;     * Intenta actualizar el archivo de highscores con un nuevo puntaje.&#10;     * Si el puntaje entra en el top-5, guarda y devuelve true.&#10;     * Si no, no modifica el archivo y devuelve false.&#10;     *&#10;     * @param nombre Nombre del jugador&#10;     * @param puntaje Puntaje obtenido&#10;     * @return true si se obtuvo un nuevo highscore y se guardó&#10;     */&#10;    public boolean actualizarHighscore(String nombre, int puntaje) {&#10;        return actualizarHighscore(nombre, puntaje, DEFAULT_FILE);&#10;    }&#10;&#10;    /**&#10;     * Versión que recibe ruta de archivo (útil para tests).&#10;     */&#10;    public boolean actualizarHighscore(String nombre, int puntaje, String rutaArchivo) {&#10;        try {&#10;            List&lt;HighscoreEntry&gt; oldEntries = cargarDesdeArchivo(rutaArchivo);&#10;&#10;            // Determinar si el nuevo puntaje califica&#10;            boolean isHighscore = false;&#10;            if (oldEntries.size() &lt; MAX_ENTRIES) {&#10;                isHighscore = true;&#10;            } else {&#10;                // Lista ya ordenada de mayor a menor&#10;                HighscoreEntry last = oldEntries.get(oldEntries.size() - 1);&#10;                if (puntaje &gt; last.getPuntaje()) {&#10;                    isHighscore = true;&#10;                }&#10;            }&#10;&#10;            if (!isHighscore) {&#10;                return false;&#10;            }&#10;&#10;            // Añadir, ordenar y recortar a top N&#10;            oldEntries.add(new HighscoreEntry(nombre, puntaje));&#10;            Collections.sort(oldEntries);&#10;            List&lt;HighscoreEntry&gt; top = oldEntries.subList(0, Math.min(oldEntries.size(), MAX_ENTRIES));&#10;            guardarEnArchivo(top, rutaArchivo);&#10;            return true;&#10;        } catch (IOException e) {&#10;            consola.mostrarError(&quot;Error al leer/escribir highscores: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;    private List&lt;HighscoreEntry&gt; cargarDesdeArchivo(String rutaArchivo) throws IOException {&#10;        Path path = Path.of(rutaArchivo);&#10;        if (!Files.exists(path)) {&#10;            // Archivo no existe -&gt; retornar vacío&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        String contenido = Files.readString(path, StandardCharsets.UTF_8).trim();&#10;        if (contenido.isEmpty()) {&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        List&lt;HighscoreEntry&gt; list = new ArrayList&lt;&gt;();&#10;        try {&#10;            String body = contenido;&#10;            if (body.startsWith(&quot;[&quot;) &amp;&amp; body.endsWith(&quot;]&quot;)) {&#10;                body = body.substring(1, body.length() - 1).trim();&#10;            }&#10;            if (body.isEmpty()) return list;&#10;&#10;            // Reemplazar separador estándar '},{' por un separador único y dividir&#10;            String normalized = body.replace(&quot;},{&quot;, &quot;}||{&quot;);&#10;            String[] objetos = normalized.split(&quot;\\|\\|&quot;);&#10;            for (String obj : objetos) {&#10;                String o = obj.trim();&#10;                if (!o.startsWith(&quot;{&quot;)) o = &quot;{&quot; + o;&#10;                if (!o.endsWith(&quot;}&quot;)) o = o + &quot;}&quot;;&#10;&#10;                String nombre = extraerValorString(o, &quot;nombre&quot;);&#10;                int puntaje = extraerValorInt(o, &quot;puntaje&quot;);&#10;                if (nombre != null) {&#10;                    list.add(new HighscoreEntry(nombre, puntaje));&#10;                }&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            // Si falla el parseo, devolver lista vacía para no romper el flujo&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        Collections.sort(list);&#10;        return list;&#10;    }&#10;&#10;    private void guardarEnArchivo(List&lt;HighscoreEntry&gt; entries, String rutaArchivo) throws IOException {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;[&quot;);&#10;        boolean first = true;&#10;        for (HighscoreEntry e : entries) {&#10;            if (!first) sb.append(&quot;,&quot;);&#10;            first = false;&#10;            sb.append(&quot;{\&quot;nombre\&quot;:\&quot;&quot;).append(escape(e.getNombre())).append(&quot;\&quot;,\&quot;puntaje\&quot;:&quot;).append(e.getPuntaje()).append(&quot;}&quot;);&#10;        }&#10;        sb.append(&quot;]&quot;);&#10;&#10;        Files.writeString(Path.of(rutaArchivo), sb.toString(), StandardCharsets.UTF_8);&#10;    }&#10;&#10;    private String escape(String s) {&#10;        return s.replace(&quot;\\&quot;, &quot;\\\\&quot;).replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;);&#10;    }&#10;&#10;    private String extraerValorString(String json, String key) {&#10;        String keyQuoted = &quot;\&quot;&quot; + key + &quot;\&quot;&quot;;&#10;        int idx = json.indexOf(keyQuoted);&#10;        if (idx == -1) return null;&#10;        int colon = json.indexOf(':', idx + keyQuoted.length());&#10;        if (colon == -1) return null;&#10;        int startQuote = json.indexOf('&quot;', colon + 1);&#10;        if (startQuote == -1) return null;&#10;        int endQuote = json.indexOf('&quot;', startQuote + 1);&#10;        if (endQuote == -1) return null;&#10;        return json.substring(startQuote + 1, endQuote);&#10;    }&#10;&#10;    private int extraerValorInt(String json, String key) {&#10;        String keyQuoted = &quot;\&quot;&quot; + key + &quot;\&quot;&quot;;&#10;        int idx = json.indexOf(keyQuoted);&#10;        if (idx == -1) return 0;&#10;        int colon = json.indexOf(':', idx + keyQuoted.length());&#10;        if (colon == -1) return 0;&#10;        int start = colon + 1;&#10;        // saltar espacios&#10;        while (start &lt; json.length() &amp;&amp; Character.isWhitespace(json.charAt(start))) start++;&#10;        int end = start;&#10;        while (end &lt; json.length() &amp;&amp; (Character.isDigit(json.charAt(end)) || json.charAt(end) == '-')) end++;&#10;        try {&#10;            return Integer.parseInt(json.substring(start, end));&#10;        } catch (NumberFormatException e) {&#10;            return 0;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package Modelo;&#10;&#10;import Vista.InterfazConsola;&#10;&#10;import java.io.*;&#10;import java.nio.charset.StandardCharsets;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;/**&#10; * Gestor simple de highscores para modo SOLO.&#10; * &lt;p&gt;&#10; * Mantiene las top 5 entradas en un archivo JSON simple.&#10; * Implementa un fallback sencillo sin depender de librerías externas.&#10; * &lt;/p&gt;&#10; */&#10;public class HighscoreManager {&#10;    private static final String DEFAULT_FILE = &quot;highscores_solo.json&quot;;&#10;    private static final int MAX_ENTRIES = 5;&#10;&#10;    private final InterfazConsola consola = InterfazConsola.obtenerInstancia();&#10;&#10;    /**&#10;     * Intenta actualizar el archivo de highscores con un nuevo puntaje.&#10;     * Si el puntaje entra en el top-5, guarda y devuelve true.&#10;     * Si no, no modifica el archivo y devuelve false.&#10;     *&#10;     * @param nombre Nombre del jugador&#10;     * @param puntaje Puntaje obtenido&#10;     * @return true si se obtuvo un nuevo highscore y se guardó&#10;     */&#10;    public boolean actualizarHighscore(String nombre, int puntaje) {&#10;        return actualizarHighscore(nombre, puntaje, DEFAULT_FILE);&#10;    }&#10;&#10;    /**&#10;     * Versión que recibe ruta de archivo (útil para tests).&#10;     */&#10;    public boolean actualizarHighscore(String nombre, int puntaje, String rutaArchivo) {&#10;        try {&#10;            List&lt;HighscoreEntry&gt; oldEntries = cargarDesdeArchivo(rutaArchivo);&#10;&#10;            // Determinar si el nuevo puntaje califica&#10;            boolean isHighscore = false;&#10;            if (oldEntries.size() &lt; MAX_ENTRIES) {&#10;                isHighscore = true;&#10;            } else {&#10;                // Lista ya ordenada de mayor a menor&#10;                HighscoreEntry last = oldEntries.get(oldEntries.size() - 1);&#10;                if (puntaje &gt; last.getPuntaje()) {&#10;                    isHighscore = true;&#10;                }&#10;            }&#10;&#10;            if (!isHighscore) {&#10;                return false;&#10;            }&#10;&#10;            // Añadir, ordenar y recortar a top N&#10;            oldEntries.add(new HighscoreEntry(nombre, puntaje));&#10;            Collections.sort(oldEntries);&#10;            List&lt;HighscoreEntry&gt; top = oldEntries.subList(0, Math.min(oldEntries.size(), MAX_ENTRIES));&#10;            guardarEnArchivo(top, rutaArchivo);&#10;            return true;&#10;        } catch (IOException e) {&#10;            consola.mostrarError(&quot;Error al leer/escribir highscores: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Devuelve el top N (hasta MAX_ENTRIES) desde el archivo por defecto.&#10;     */&#10;    public List&lt;HighscoreEntry&gt; obtenerTop() {&#10;        return obtenerTop(DEFAULT_FILE);&#10;    }&#10;&#10;    /**&#10;     * Devuelve el top N desde la ruta indicada.&#10;     */&#10;    public List&lt;HighscoreEntry&gt; obtenerTop(String rutaArchivo) {&#10;        try {&#10;            List&lt;HighscoreEntry&gt; all = cargarDesdeArchivo(rutaArchivo);&#10;            return all.subList(0, Math.min(all.size(), MAX_ENTRIES));&#10;        } catch (IOException e) {&#10;            consola.mostrarError(&quot;No se pudo leer highscores: &quot; + e.getMessage());&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;    }&#10;&#10;    private List&lt;HighscoreEntry&gt; cargarDesdeArchivo(String rutaArchivo) throws IOException {&#10;        Path path = Path.of(rutaArchivo);&#10;        if (!Files.exists(path)) {&#10;            // Archivo no existe -&gt; retornar vacío&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        String contenido = Files.readString(path, StandardCharsets.UTF_8).trim();&#10;        if (contenido.isEmpty()) {&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        List&lt;HighscoreEntry&gt; list = new ArrayList&lt;&gt;();&#10;        try {&#10;            String body = contenido;&#10;            if (body.startsWith(&quot;[&quot;) &amp;&amp; body.endsWith(&quot;]&quot;)) {&#10;                body = body.substring(1, body.length() - 1).trim();&#10;            }&#10;            if (body.isEmpty()) return list;&#10;&#10;            // Reemplazar separador estándar '},{' por un separador único y dividir&#10;            String normalized = body.replace(&quot;},{&quot;, &quot;}||{&quot;);&#10;            String[] objetos = normalized.split(&quot;\\|\\|&quot;);&#10;            for (String obj : objetos) {&#10;                String o = obj.trim();&#10;                if (!o.startsWith(&quot;{&quot;)) o = &quot;{&quot; + o;&#10;                if (!o.endsWith(&quot;}&quot;)) o = o + &quot;}&quot;;&#10;&#10;                String nombre = extraerValorString(o, &quot;nombre&quot;);&#10;                int puntaje = extraerValorInt(o, &quot;puntaje&quot;);&#10;                if (nombre != null) {&#10;                    list.add(new HighscoreEntry(nombre, puntaje));&#10;                }&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            // Si falla el parseo, devolver lista vacía para no romper el flujo&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        Collections.sort(list);&#10;        return list;&#10;    }&#10;&#10;    private void guardarEnArchivo(List&lt;HighscoreEntry&gt; entries, String rutaArchivo) throws IOException {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;[&quot;);&#10;        boolean first = true;&#10;        for (HighscoreEntry e : entries) {&#10;            if (!first) sb.append(&quot;,&quot;);&#10;            first = false;&#10;            sb.append(&quot;{\&quot;nombre\&quot;:\&quot;&quot;).append(escape(e.getNombre())).append(&quot;\&quot;,\&quot;puntaje\&quot;:&quot;).append(e.getPuntaje()).append(&quot;}&quot;);&#10;        }&#10;        sb.append(&quot;]&quot;);&#10;&#10;        Files.writeString(Path.of(rutaArchivo), sb.toString(), StandardCharsets.UTF_8);&#10;    }&#10;&#10;    private String escape(String s) {&#10;        return s.replace(&quot;\\&quot;, &quot;\\\\&quot;).replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;);&#10;    }&#10;&#10;    private String extraerValorString(String json, String key) {&#10;        String keyQuoted = &quot;\&quot;&quot; + key + &quot;\&quot;&quot;;&#10;        int idx = json.indexOf(keyQuoted);&#10;        if (idx == -1) return null;&#10;        int colon = json.indexOf(':', idx + keyQuoted.length());&#10;        if (colon == -1) return null;&#10;        int startQuote = json.indexOf('&quot;', colon + 1);&#10;        if (startQuote == -1) return null;&#10;        int endQuote = json.indexOf('&quot;', startQuote + 1);&#10;        if (endQuote == -1) return null;&#10;        return json.substring(startQuote + 1, endQuote);&#10;    }&#10;&#10;    private int extraerValorInt(String json, String key) {&#10;        String keyQuoted = &quot;\&quot;&quot; + key + &quot;\&quot;&quot;;&#10;        int idx = json.indexOf(keyQuoted);&#10;        if (idx == -1) return 0;&#10;        int colon = json.indexOf(':', idx + keyQuoted.length());&#10;        if (colon == -1) return 0;&#10;        int start = colon + 1;&#10;        // saltar espacios&#10;        while (start &lt; json.length() &amp;&amp; Character.isWhitespace(json.charAt(start))) start++;&#10;        int end = start;&#10;        while (end &lt; json.length() &amp;&amp; (Character.isDigit(json.charAt(end)) || json.charAt(end) == '-')) end++;&#10;        try {&#10;            return Integer.parseInt(json.substring(start, end));&#10;        } catch (NumberFormatException e) {&#10;            return 0;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>